"use strict";

import React, { useLayoutEffect, useRef } from 'react';
import { Image, Platform, StyleSheet, View, processColor } from 'react-native';
import { BottomTabBarHeightContext } from "./utils/BottomTabBarHeightContext.js";

// eslint-disable-next-line @react-native/no-deep-imports

import NativeTabView from './TabViewNativeComponent';
import useLatestCallback from 'use-latest-callback';
import DelayedFreeze from "./DelayedFreeze.js";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
const isAppleSymbol = icon => icon?.sfSymbol;
const ANDROID_MAX_TABS = 100;
const TabView = ({
  navigationState,
  renderScene,
  onIndexChange,
  onTabLongPress,
  rippleColor,
  tabBarActiveTintColor: activeTintColor,
  tabBarInactiveTintColor: inactiveTintColor,
  getBadge = ({
    route
  }) => route.badge,
  getLazy = ({
    route
  }) => route.lazy,
  getLabelText = ({
    route
  }) => route.title,
  getIcon = ({
    route,
    focused
  }) => route.unfocusedIcon ? focused ? route.focusedIcon : route.unfocusedIcon : route.focusedIcon,
  getHidden = ({
    route
  }) => route.hidden,
  getActiveTintColor = ({
    route
  }) => route.activeTintColor,
  getTestID = ({
    route
  }) => route.testID,
  getRole = ({
    route
  }) => route.role,
  getSceneStyle = ({
    route
  }) => route.style,
  getPreventsDefault = ({
    route
  }) => route.preventsDefault,
  hapticFeedbackEnabled = false,
  // Android's native behavior is to show labels when there are less than 4 tabs. We leave it as undefined to use the platform default behavior.
  labeled = Platform.OS !== 'android' ? true : undefined,
  getFreezeOnBlur = ({
    route
  }) => route.freezeOnBlur,
  tabBar: renderCustomTabBar,
  tabBarStyle,
  tabLabelStyle,
  ...props
}) => {
  // @ts-ignore
  const focusedKey = navigationState.routes[navigationState.index].key;
  const customTabBarWrapperRef = useRef(null);
  const [tabBarHeight, setTabBarHeight] = React.useState(0);
  const [measuredDimensions, setMeasuredDimensions] = React.useState({
    width: '100%',
    height: '100%'
  });
  const trimmedRoutes = React.useMemo(() => {
    if (Platform.OS === 'android' && navigationState.routes.length > ANDROID_MAX_TABS) {
      console.warn(`TabView only supports up to ${ANDROID_MAX_TABS} tabs on Android`);
      return navigationState.routes.slice(0, ANDROID_MAX_TABS);
    }
    return navigationState.routes;
  }, [navigationState.routes]);

  /**
   * List of loaded tabs, tabs will be loaded when navigated to.
   */
  const [loaded, setLoaded] = React.useState([focusedKey]);
  if (!loaded.includes(focusedKey)) {
    // Set the current tab to be loaded if it was not loaded before
    setLoaded(loaded => [...loaded, focusedKey]);
  }
  const icons = React.useMemo(() => trimmedRoutes.map(route => getIcon({
    route,
    focused: route.key === focusedKey
  })), [focusedKey, getIcon, trimmedRoutes]);
  const items = React.useMemo(() => trimmedRoutes.map((route, index) => {
    const icon = icons[index];
    const isSfSymbol = isAppleSymbol(icon);
    if (Platform.OS === 'android' && isSfSymbol) {
      console.warn('SF Symbols are not supported on Android. Use require() or pass uri to load an image instead.');
    }
    return {
      key: route.key,
      title: getLabelText({
        route
      }) ?? route.key,
      sfSymbol: isSfSymbol ? icon.sfSymbol : undefined,
      badge: getBadge?.({
        route
      }),
      activeTintColor: processColor(getActiveTintColor({
        route
      })),
      hidden: getHidden?.({
        route
      }),
      testID: getTestID?.({
        route
      }),
      role: getRole?.({
        route
      }),
      preventsDefault: getPreventsDefault?.({
        route
      })
    };
  }), [trimmedRoutes, icons, getLabelText, getBadge, getActiveTintColor, getHidden, getTestID, getRole, getPreventsDefault]);
  const resolvedIconAssets = React.useMemo(() =>
  // Pass empty object for icons that are not provided to avoid index mismatch on native side.
  icons.map(icon => icon && !isAppleSymbol(icon) ?
  // @ts-expect-error: TODO: Migrate of deep imports
  Image.resolveAssetSource(icon) : {
    uri: ''
  }), [icons]);
  const jumpTo = useLatestCallback(key => {
    const index = trimmedRoutes.findIndex(route => route.key === key);
    onIndexChange(index);
  });
  const handleTabLongPress = React.useCallback(({
    nativeEvent: {
      key
    }
  }) => {
    const index = trimmedRoutes.findIndex(route => route.key === key);
    onTabLongPress?.(index);
  }, [trimmedRoutes, onTabLongPress]);
  const handlePageSelected = React.useCallback(({
    nativeEvent: {
      key
    }
  }) => {
    jumpTo(key);
  }, [jumpTo]);
  const handleTabBarMeasured = React.useCallback(({
    nativeEvent: {
      height
    }
  }) => {
    setTabBarHeight(height);
  }, [setTabBarHeight]);
  const handleNativeLayout = React.useCallback(({
    nativeEvent: {
      width,
      height
    }
  }) => {
    setMeasuredDimensions({
      width,
      height
    });
  }, [setMeasuredDimensions]);
  useLayoutEffect(() => {
    // If we are rendering a custom tab bar, we need to measure it to set the tab bar height.
    if (renderCustomTabBar && customTabBarWrapperRef.current) {
      customTabBarWrapperRef.current.measure((_x, _y, _width, height) => {
        setTabBarHeight(height);
      });
    }
  }, [renderCustomTabBar]);
  return /*#__PURE__*/_jsxs(BottomTabBarHeightContext.Provider, {
    value: tabBarHeight,
    children: [/*#__PURE__*/_jsx(NativeTabView, {
      ...props,
      ...tabLabelStyle,
      style: styles.fullWidth,
      items: items
      // When rendering a custom tab bar, icons can be React elements, which will not be properly resolved.
      ,
      icons: renderCustomTabBar ? undefined : resolvedIconAssets,
      selectedPage: focusedKey,
      tabBarHidden: !!renderCustomTabBar,
      onTabLongPress: handleTabLongPress,
      onPageSelected: handlePageSelected,
      onTabBarMeasured: handleTabBarMeasured,
      onNativeLayout: handleNativeLayout,
      hapticFeedbackEnabled: hapticFeedbackEnabled,
      activeTintColor: activeTintColor,
      inactiveTintColor: inactiveTintColor,
      barTintColor: tabBarStyle?.backgroundColor,
      rippleColor: rippleColor,
      labeled: labeled,
      children: trimmedRoutes.map(route => {
        if (getLazy({
          route
        }) !== false && !loaded.includes(route.key)) {
          // Don't render a screen if we've never navigated to it
          return /*#__PURE__*/_jsx(View, {
            collapsable: false,
            style: styles.fullWidth
          }, route.key);
        }
        const focused = route.key === focusedKey;
        const freeze = !focused ? getFreezeOnBlur({
          route
        }) : false;
        const customStyle = getSceneStyle({
          route
        });
        return /*#__PURE__*/_jsx(View, {
          style: [styles.screen, renderCustomTabBar ? styles.fullWidth : measuredDimensions, customStyle],
          collapsable: false,
          pointerEvents: focused ? 'auto' : 'none',
          accessibilityElementsHidden: !focused,
          importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',
          children: /*#__PURE__*/_jsx(DelayedFreeze, {
            freeze: !!freeze,
            children: renderScene({
              route,
              jumpTo
            })
          })
        }, route.key);
      })
    }), renderCustomTabBar ? /*#__PURE__*/_jsx(View, {
      ref: customTabBarWrapperRef,
      children: renderCustomTabBar()
    }) : null]
  });
};
const styles = StyleSheet.create({
  fullWidth: {
    width: '100%',
    height: '100%',
    flex: 1
  },
  screen: {
    position: 'absolute'
  }
});
export default TabView;
//# sourceMappingURL=TabView.js.map