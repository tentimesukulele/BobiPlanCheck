"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _BottomTabBarHeightContext = require("./utils/BottomTabBarHeightContext.js");
var _TabViewNativeComponent = _interopRequireDefault(require("./TabViewNativeComponent"));
var _useLatestCallback = _interopRequireDefault(require("use-latest-callback"));
var _DelayedFreeze = _interopRequireDefault(require("./DelayedFreeze.js"));
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// eslint-disable-next-line @react-native/no-deep-imports

const isAppleSymbol = icon => icon?.sfSymbol;
const ANDROID_MAX_TABS = 100;
const TabView = ({
  navigationState,
  renderScene,
  onIndexChange,
  onTabLongPress,
  rippleColor,
  tabBarActiveTintColor: activeTintColor,
  tabBarInactiveTintColor: inactiveTintColor,
  getBadge = ({
    route
  }) => route.badge,
  getLazy = ({
    route
  }) => route.lazy,
  getLabelText = ({
    route
  }) => route.title,
  getIcon = ({
    route,
    focused
  }) => route.unfocusedIcon ? focused ? route.focusedIcon : route.unfocusedIcon : route.focusedIcon,
  getHidden = ({
    route
  }) => route.hidden,
  getActiveTintColor = ({
    route
  }) => route.activeTintColor,
  getTestID = ({
    route
  }) => route.testID,
  getRole = ({
    route
  }) => route.role,
  getSceneStyle = ({
    route
  }) => route.style,
  getPreventsDefault = ({
    route
  }) => route.preventsDefault,
  hapticFeedbackEnabled = false,
  // Android's native behavior is to show labels when there are less than 4 tabs. We leave it as undefined to use the platform default behavior.
  labeled = _reactNative.Platform.OS !== 'android' ? true : undefined,
  getFreezeOnBlur = ({
    route
  }) => route.freezeOnBlur,
  tabBar: renderCustomTabBar,
  tabBarStyle,
  tabLabelStyle,
  ...props
}) => {
  // @ts-ignore
  const focusedKey = navigationState.routes[navigationState.index].key;
  const customTabBarWrapperRef = (0, _react.useRef)(null);
  const [tabBarHeight, setTabBarHeight] = _react.default.useState(0);
  const [measuredDimensions, setMeasuredDimensions] = _react.default.useState({
    width: '100%',
    height: '100%'
  });
  const trimmedRoutes = _react.default.useMemo(() => {
    if (_reactNative.Platform.OS === 'android' && navigationState.routes.length > ANDROID_MAX_TABS) {
      console.warn(`TabView only supports up to ${ANDROID_MAX_TABS} tabs on Android`);
      return navigationState.routes.slice(0, ANDROID_MAX_TABS);
    }
    return navigationState.routes;
  }, [navigationState.routes]);

  /**
   * List of loaded tabs, tabs will be loaded when navigated to.
   */
  const [loaded, setLoaded] = _react.default.useState([focusedKey]);
  if (!loaded.includes(focusedKey)) {
    // Set the current tab to be loaded if it was not loaded before
    setLoaded(loaded => [...loaded, focusedKey]);
  }
  const icons = _react.default.useMemo(() => trimmedRoutes.map(route => getIcon({
    route,
    focused: route.key === focusedKey
  })), [focusedKey, getIcon, trimmedRoutes]);
  const items = _react.default.useMemo(() => trimmedRoutes.map((route, index) => {
    const icon = icons[index];
    const isSfSymbol = isAppleSymbol(icon);
    if (_reactNative.Platform.OS === 'android' && isSfSymbol) {
      console.warn('SF Symbols are not supported on Android. Use require() or pass uri to load an image instead.');
    }
    return {
      key: route.key,
      title: getLabelText({
        route
      }) ?? route.key,
      sfSymbol: isSfSymbol ? icon.sfSymbol : undefined,
      badge: getBadge?.({
        route
      }),
      activeTintColor: (0, _reactNative.processColor)(getActiveTintColor({
        route
      })),
      hidden: getHidden?.({
        route
      }),
      testID: getTestID?.({
        route
      }),
      role: getRole?.({
        route
      }),
      preventsDefault: getPreventsDefault?.({
        route
      })
    };
  }), [trimmedRoutes, icons, getLabelText, getBadge, getActiveTintColor, getHidden, getTestID, getRole, getPreventsDefault]);
  const resolvedIconAssets = _react.default.useMemo(() =>
  // Pass empty object for icons that are not provided to avoid index mismatch on native side.
  icons.map(icon => icon && !isAppleSymbol(icon) ?
  // @ts-expect-error: TODO: Migrate of deep imports
  _reactNative.Image.resolveAssetSource(icon) : {
    uri: ''
  }), [icons]);
  const jumpTo = (0, _useLatestCallback.default)(key => {
    const index = trimmedRoutes.findIndex(route => route.key === key);
    onIndexChange(index);
  });
  const handleTabLongPress = _react.default.useCallback(({
    nativeEvent: {
      key
    }
  }) => {
    const index = trimmedRoutes.findIndex(route => route.key === key);
    onTabLongPress?.(index);
  }, [trimmedRoutes, onTabLongPress]);
  const handlePageSelected = _react.default.useCallback(({
    nativeEvent: {
      key
    }
  }) => {
    jumpTo(key);
  }, [jumpTo]);
  const handleTabBarMeasured = _react.default.useCallback(({
    nativeEvent: {
      height
    }
  }) => {
    setTabBarHeight(height);
  }, [setTabBarHeight]);
  const handleNativeLayout = _react.default.useCallback(({
    nativeEvent: {
      width,
      height
    }
  }) => {
    setMeasuredDimensions({
      width,
      height
    });
  }, [setMeasuredDimensions]);
  (0, _react.useLayoutEffect)(() => {
    // If we are rendering a custom tab bar, we need to measure it to set the tab bar height.
    if (renderCustomTabBar && customTabBarWrapperRef.current) {
      customTabBarWrapperRef.current.measure((_x, _y, _width, height) => {
        setTabBarHeight(height);
      });
    }
  }, [renderCustomTabBar]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_BottomTabBarHeightContext.BottomTabBarHeightContext.Provider, {
    value: tabBarHeight,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_TabViewNativeComponent.default, {
      ...props,
      ...tabLabelStyle,
      style: styles.fullWidth,
      items: items
      // When rendering a custom tab bar, icons can be React elements, which will not be properly resolved.
      ,
      icons: renderCustomTabBar ? undefined : resolvedIconAssets,
      selectedPage: focusedKey,
      tabBarHidden: !!renderCustomTabBar,
      onTabLongPress: handleTabLongPress,
      onPageSelected: handlePageSelected,
      onTabBarMeasured: handleTabBarMeasured,
      onNativeLayout: handleNativeLayout,
      hapticFeedbackEnabled: hapticFeedbackEnabled,
      activeTintColor: activeTintColor,
      inactiveTintColor: inactiveTintColor,
      barTintColor: tabBarStyle?.backgroundColor,
      rippleColor: rippleColor,
      labeled: labeled,
      children: trimmedRoutes.map(route => {
        if (getLazy({
          route
        }) !== false && !loaded.includes(route.key)) {
          // Don't render a screen if we've never navigated to it
          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
            collapsable: false,
            style: styles.fullWidth
          }, route.key);
        }
        const focused = route.key === focusedKey;
        const freeze = !focused ? getFreezeOnBlur({
          route
        }) : false;
        const customStyle = getSceneStyle({
          route
        });
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
          style: [styles.screen, renderCustomTabBar ? styles.fullWidth : measuredDimensions, customStyle],
          collapsable: false,
          pointerEvents: focused ? 'auto' : 'none',
          accessibilityElementsHidden: !focused,
          importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_DelayedFreeze.default, {
            freeze: !!freeze,
            children: renderScene({
              route,
              jumpTo
            })
          })
        }, route.key);
      })
    }), renderCustomTabBar ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
      ref: customTabBarWrapperRef,
      children: renderCustomTabBar()
    }) : null]
  });
};
const styles = _reactNative.StyleSheet.create({
  fullWidth: {
    width: '100%',
    height: '100%',
    flex: 1
  },
  screen: {
    position: 'absolute'
  }
});
var _default = exports.default = TabView;
//# sourceMappingURL=TabView.js.map